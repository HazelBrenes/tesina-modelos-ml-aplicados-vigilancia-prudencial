```{r}
# ============================================================
# 04_mlp.Rmd
# MODELO: RED NEURONAL MULTICAPA (MLP)
# VALIDACIÓN TEMPORAL + REPETICIONES (SIN SEMILLAS)
# APLICA A CUALQUIER SEGMENTO (BANCOS / COOPERATIVAS / FINANCIERAS)
# Requiere que existan en el entorno:
#   - datos
#   - segmento_actual
#   - anios_validacion, anios_test_final
#   - n_reps, n_reps_test
#   - funciones en 03_utils.Rmd
# ============================================================
```


```{r}
# ============================================================
# RECIPE (ESPECÍFICA PARA MLP)
# ============================================================

nn_recipe <- recipe(entidad ~ ., data = datos) %>%
  update_role(periodo, anio, new_role = "id") %>%
  step_zv(all_predictors()) %>%
  step_impute_median(all_numeric_predictors()) %>%
  step_normalize(all_numeric_predictors())
```

```{r}
# ============================================================
# MALLA DE HIPERPARÁMETROS
# ============================================================

grid_nn <- expand_grid(
  hidden_units = c(5, 10, 15, 20),
  penalty      = 10^seq(-7, -1, by = 0.5),
  epochs       = c(100, 200, 300)
) %>%
  mutate(id_grid = row_number())
```

```{r}

# ============================================================
# FUNCIÓN DE EVALUACIÓN (VENTANA EXPANSIVA + REPETICIONES)
# ============================================================

evaluar_configuracion_nn <- function(hidden_units, penalty, epochs, id_grid) {
  
  nn_spec <- mlp(
    hidden_units = hidden_units,
    penalty      = penalty,
    epochs       = epochs
  ) %>%
    set_engine("nnet", trace = FALSE, MaxNWts = 20000) %>%
    set_mode("classification")
  
  nn_wf <- workflow() %>%
    add_model(nn_spec) %>%
    add_recipe(nn_recipe)
  
  expand_grid(
    anio_test = anios_validacion,
    rep       = seq_len(n_reps)
  ) %>%
    mutate(
      f1_macro = pmap_dbl(
        list(anio_test, rep),
        function(anio_test, rep) {
          
          train_data <- datos %>% filter(anio <= anio_test - 1)
          test_data  <- datos %>% filter(anio == anio_test)
          
          fit_nn <- nn_wf %>% fit(train_data)
          
          pred <- bind_cols(
            test_data %>% select(entidad),
            predict(fit_nn, test_data, type = "class")
          )
          
          metricas_desde_mc(pred) %>%
            summarise(mean(f1_k, na.rm = TRUE)) %>%
            pull()
        }
      ),
      id_grid      = id_grid,
      hidden_units = hidden_units,
      penalty      = penalty,
      epochs       = epochs
    )
}
```

```{r}
# ============================================================
# EJECUCIÓN DE LA MALLA
# ============================================================

resultados_malla_nn <- pmap_dfr(
  grid_nn,
  evaluar_configuracion_nn
)

saveRDS(
  resultados_malla_nn,
    here::here(
    "salidas",
  glue::glue(
    "resultados_malla_nn_{tolower(segmento_actual)}.rds")
  )
)

```

```{r}
# ============================================================
# RANKING ROBUSTO DE CONFIGURACIONES
# ============================================================

ranking_malla_nn <- resultados_malla_nn %>%
  group_by(id_grid, hidden_units, penalty, epochs) %>%
  summarise(
    f1_mean = mean(f1_macro),
    f1_sd   = sd(f1_macro),
    f1_p10  = quantile(f1_macro, 0.10),
    f1_min  = min(f1_macro),
    .groups = "drop"
  ) %>%
  arrange(desc(f1_mean), desc(f1_p10))

mejor_configuracion_nn <- ranking_malla_nn %>% slice(1)

mejor_configuracion_nn
```

```{r}

# ============================================================
# MODELO FINAL (TEST FUERA DE MUESTRA CON REPETICIONES)
# ============================================================

nn_final_spec <- mlp(
  hidden_units = mejor_configuracion_nn$hidden_units,
  penalty      = mejor_configuracion_nn$penalty,
  epochs       = mejor_configuracion_nn$epochs
) %>%
  set_engine("nnet", trace = FALSE, MaxNWts = 20000) %>%
  set_mode("classification")

nn_final_wf <- workflow() %>%
  add_model(nn_final_spec) %>%
  add_recipe(nn_recipe)
```

```{r}

# ============================================================
# TEST FINAL (2023–2025) CON REPETICIONES
# ============================================================

resultados_test_final_nn <- expand_grid(
  anio_test = anios_test_final,
  rep       = seq_len(n_reps_test)
) %>%
  mutate(
    resultado = pmap(
      list(anio_test, rep),
      function(anio_test, rep) {
        
        train_data <- datos %>% filter(anio <= anio_test - 1)
        test_data  <- datos %>% filter(anio == anio_test)
        
        fit_nn <- nn_final_wf %>% fit(train_data)
        
        pred <- bind_cols(
          test_data %>% select(entidad),
          predict(fit_nn, test_data, type = "class")
        )
        
        metricas <- metricas_desde_mc(pred)
        
        tibble(
          f1_macro        = mean(metricas$f1_k, na.rm = TRUE),
          precision_macro = mean(metricas$precision_k, na.rm = TRUE)
        )
      }
    )
  ) %>%
  unnest(resultado)
```

```{r}

# ============================================================
# RESUMEN TEST FINAL POR AÑO
# ============================================================

resultados_test_final_resumen_nn <- resultados_test_final_nn %>%
  group_by(anio_test) %>%
  summarise(
    f1_macro_mean        = mean(f1_macro),
    f1_macro_sd          = sd(f1_macro),
    precision_macro_mean = mean(precision_macro),
    .groups = "drop"
  )

resultados_test_final_resumen_nn

saveRDS(
  resultados_test_final_resumen_nn,
    here::here(
    "salidas",
  glue::glue(
    "resultados_test_final_nn_{tolower(segmento_actual)}.rds"
  )
  )
)
```

```{r}
# ============================================================
# MATRICES DE CONFUSIÓN Y MÉTRICAS POR ENTIDAD
# ============================================================

predicciones_test_final_nn <- expand_grid(
  anio_test = anios_test_final,
  rep       = seq_len(n_reps_test)
) %>%
  mutate(
    pred = pmap(
      list(anio_test, rep),
      function(anio_test, rep) {
        
        train_data <- datos %>% filter(anio <= anio_test - 1)
        test_data  <- datos %>% filter(anio == anio_test)
        
        fit_nn <- nn_final_wf %>% fit(train_data)
        
        bind_cols(
          test_data %>% select(entidad),
          predict(fit_nn, test_data, type = "class")
        )
      }
    )
  ) %>%
  unnest(pred)

matrices_confusion_nn <- predicciones_test_final_nn %>%
  nest_by(anio_test, rep) %>%
  mutate(
    cm = list(
      {
        df <- as_tibble(
          as.data.frame(
            yardstick::conf_mat(
              data,
              truth    = entidad,
              estimate = .pred_class
            )$table
          )
        )
        names(df)[1:3] <- c("truth", "estimate", "n")
        df
      }
    )
  ) %>%
  unnest(cm) %>%
  ungroup() %>%
  select(-data)


metricas_entidad_nn <- predicciones_test_final_nn %>%
  group_by(anio_test, rep) %>%
  group_modify(~ metricas_por_entidad(.x)) %>%
  ungroup() %>%
  group_by(anio_test, entidad) %>%
  summarise(
    precision = mean(precision, na.rm = TRUE),
    recall    = mean(recall, na.rm = TRUE),
    f1        = mean(f1, na.rm = TRUE),
    .groups = "drop"
  )

saveRDS(
  metricas_entidad_nn,
  here::here(
    "salidas",
    glue::glue("metricas_por_entidad_nn_{tolower(segmento_actual)}.rds")
  )
)

matriz_promedio_nn <- matrices_confusion_nn %>%
  group_by(anio_test, truth, estimate) %>%
  summarise(
    n_mean = mean(n),
    .groups = "drop"
  )


saveRDS(
  matrices_confusion_nn,
  here::here(
    "salidas",
    glue::glue("matrices_confusion_nn_{tolower(segmento_actual)}.rds")
  )
)

saveRDS(
  matriz_promedio_nn,
  here::here(
    "salidas",
    glue::glue("matriz_promedio_nn_{tolower(segmento_actual)}.rds")
  )
)


```

